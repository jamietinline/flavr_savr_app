import { useLocation } from "react-router-dom";
import { useState } from "react";
import IngredientChecklist from "../views/IngredientChecklist";
import RecipeIdeas from "../views/RecipeIdeas";
import FullRecipe from "../views/FullRecipe";


export default function RecipeGenerateProcess() {
  const location = useLocation();
  const API_URL = process.env.API_URL;
   // Initial AI-generated ingredient list
  const initialReply = location.state?.reply;     
  // User-provided ingredient array   
  const userIngredients = location.state?.ingredients; 
  // Track which stage of the recipe generation process the user is on
  const [stage, setStage] = useState("checklist"); // "checklist" | "ideas" | "recipe"
  // Store the ingredient text response from AI
  const [ingredientsReply, setIngredientsReply] = useState(initialReply);
  // Keep track of previous ingredients to avoid duplicates when refreshing
  const [previousIngredients, setPreviousIngredients] = useState([]);
  // Track which ingredients the user selects for generating recipes
  const [selectedIngredients, setSelectedIngredients] = useState([]);
  // Store the list of recipe ideas returned by AI
  const [recipeIdeas, setRecipeIdeas] = useState([]);
  // Store the detailed full recipe generated by AI
  const [fullRecipe, setFullRecipe] = useState(null);
  // Store the recipe title for display
  const [recipeTitle, setRecipeTitle] = useState("");

  // Parse current AI ingredients response into an array for tracking
  const currentIngredients = ingredientsReply
    ? ingredientsReply
        .split("\n")                   // Split response by new lines
        .filter(line => /^\d+\./.test(line)) // Keep only numbered lines like "1. Eggs"
        .map(line => line.replace(/^\d+\.\s*/, "")) // Remove numbering
    : [];

  // Track ingredients the first time the component loads
  if (currentIngredients.length > 0 && previousIngredients.length === 0) {
    setPreviousIngredients(currentIngredients);
  }

  // Function to refresh the ingredient list by asking AI for alternatives
  const handleRefreshIngredients = async () => {
    // Check if original ingredients exist
    if (!userIngredients || userIngredients.length === 0) {
      alert("No original ingredients found. Please start from the home page.");
      return;
    }

    try {
      // Call backend API to get refreshed ingredients
      const res = await fetch(`${API_URL}/claude/refresh`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          ingredients: userIngredients,
          previousSuggestions: previousIngredients
        }),
      });

      if (!res.ok) {
        throw new Error(`HTTP error! status: ${res.status}`);
      }

      const data = await res.json();

      // Parse the AI reply into an array of ingredient strings
      const newIngredients = data.reply
        .split("\n")
        .filter(line => /^\d+\./.test(line))
        .map(line => line.replace(/^\d+\.\s*/, ""));

      // Update state
      setIngredientsReply(data.reply);
      setPreviousIngredients([...previousIngredients, ...newIngredients]); // Keep track of all previous suggestions
    } catch (err) {
      console.error("Error refreshing ingredients:", err);
      alert("Failed to refresh ingredients. Is your backend server running?");
    }
  };

  // Function to generate recipe ideas based on selected ingredients
  const handleGenerateIdeas = async (selected) => {
  setSelectedIngredients(selected);

  try {
    const res = await fetch(`${API_URL}/claude/recipe-ideas`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ ingredients: selected }),
    });

    if (!res.ok) {
      throw new Error(`HTTP error! status: ${res.status}`);
    }

    const data = await res.json();
    console.log("Recipe ideas response:", data);

    let ideas = [];

    // Check if data.reply.recipes exists (new API format)
    if (data.reply?.recipes && Array.isArray(data.reply.recipes)) {
      ideas = data.reply.recipes;
    }
    // Check if data.reply exists and is a string
    else if (data.reply && typeof data.reply === 'string') {
      try {
        // Try to parse as JSON first
        const parsed = JSON.parse(data.reply);
        ideas = parsed.recipes || parsed;
      } catch {
        // Fallback: parse plain text list (e.g., "1. Veggie Pasta\n2. Chickpea Curry")
        ideas = data.reply
          .split("\n")
          .filter(line => line.trim() && /^\d+[\.\)]\s*/.test(line.trim()))
          .map(line => {
            const title = line
              .replace(/^\d+[\.\)]\s*/, "") // Remove numbering (1. or 1))
              .replace(/\*\*/g, "") // Remove markdown bold
              .replace(/\*/g, "") // Remove markdown italic
              .replace(/`/g, "") // Remove code backticks
              .trim();
            return { title };
          });
      }
    }
    // Check if data.reply is already an array
    else if (Array.isArray(data.reply)) {
      ideas = data.reply;
    }
    // Check if data itself is an array
    else if (Array.isArray(data)) {
      ideas = data;
    }
    // Check if data has recipes property
    else if (data.recipes && Array.isArray(data.recipes)) {
      ideas = data.recipes;
    }
    else {
      console.error("Unexpected response format. Full data:", JSON.stringify(data, null, 2));
      throw new Error("Unexpected response format. Check console for details.");
    }

    if (!ideas || ideas.length === 0) {
      throw new Error("No recipe ideas were generated. Please try again.");
    }

    console.log("Final ideas array:", ideas);
    setRecipeIdeas(ideas);
    setStage("ideas");
  } catch (err) {
    console.error("Error generating ideas:", err);
    alert("Failed to generate recipe ideas. Check console for details.");
  }
};

  // Function to generate the full recipe from a selected recipe idea
const handleGenerateFullRecipe = async (selectedRecipe, selectedIngredients) => {
  try {
    
    const res = await fetch(`${API_URL}/claude/full-recipe`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        recipeIdea: selectedRecipe.title,
        ingredients: selectedIngredients,
      }),
    });

    if (!res.ok) {
      throw new Error(`HTTP error! status: ${res.status}`);
    }

    const recipeData = await res.json();
    console.log("Full recipe response:", recipeData);

    // Handle different response structures
    let parsedRecipe;

    // Backend returns { reply: recipeObject } where recipeObject has title, ingredients, etc.
    if (recipeData.reply) {
      const recipe = recipeData.reply;
      // If reply is a string, try to parse it as JSON
      if (typeof recipe === 'string') {
        try {
          parsedRecipe = JSON.parse(recipe);
        } catch (err) {
          console.error("Failed to parse recipe JSON:", err);
          alert("Received unexpected recipe format from server.");
          return;
        }
      } else {
        // reply is already an object with the recipe data
        parsedRecipe = recipe;
      }
    }
    // Check if it's in reply.recipe format
    else if (recipeData.reply?.recipe) {
      parsedRecipe = recipeData.reply.recipe;
    }
    // Check if recipe is at root level
    else if (recipeData.recipe) {
      parsedRecipe = recipeData.recipe;
    }
    // Otherwise use the data itself
    else {
      parsedRecipe = recipeData;
    }

    console.log("Parsed recipe:", parsedRecipe);

    // Safety defaults in case some fields are missing
    const fullRecipe = {
      title: parsedRecipe.title || selectedRecipe.title || "My Recipe",
      prepTime: parsedRecipe.prepTime || "",
      cookTime: parsedRecipe.cookTime || "",
      totalTime: parsedRecipe.totalTime || "",
      servings: parsedRecipe.servings || "",
      ingredients: parsedRecipe.ingredients || [],
      equipment: parsedRecipe.equipment || [],
      steps: parsedRecipe.steps || [],
      tips: parsedRecipe.tips || [],
    };

    setFullRecipe(fullRecipe);
    setRecipeTitle(fullRecipe.title);
    setStage("recipe");

  } catch (err) {
    console.error("Error calling Claude:", err);
    alert("Failed to generate recipe. Is your backend server running?");
  }
};


  // Render different components depending on which stage the user is in
  return (
    <>
      {stage === "checklist" && (
        <IngredientChecklist
          ingredientsReply={ingredientsReply}   // AI ingredient text
          userIngredients={userIngredients}     // Original ingredients from user
          onGenerateIdeas={handleGenerateIdeas} // Callback when generating ideas
          onRefresh={handleRefreshIngredients}  // Callback when refreshing ingredients
        />
      )}

      {stage === "ideas" && (
        <RecipeIdeas
          recipeIdeas={recipeIdeas}                     // Recipe ideas list
          selectedIngredients={selectedIngredients}     // Pass selected ingredients
          onGenerateFullRecipe={handleGenerateFullRecipe} // Callback when selecting a recipe
          onBack={() => setStage("checklist")}         // Go back to ingredient checklist
        />
      )}

      {stage === "recipe" && (
        <FullRecipe
          fullRecipe={fullRecipe}     // Full recipe object
          recipeTitle={recipeTitle}   // Recipe title
          onBack={() => setStage("ideas")} // Go back to ideas list
        />
      )}
    </>
  );
}
